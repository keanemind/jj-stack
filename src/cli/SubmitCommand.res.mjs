// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "./Utils.res.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Process from "process";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as SubmitJs from "../lib/submit.js";
import * as JjUtilsJs from "../lib/jjUtils.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function buildChangeGraph(prim) {
  return JjUtilsJs.buildChangeGraph(prim);
}

function analyzeSubmissionGraph(prim0, prim1) {
  return SubmitJs.analyzeSubmissionGraph(prim0, prim1);
}

function createSubmissionPlan(prim0, prim1, prim2, prim3, prim4, prim5) {
  return SubmitJs.createSubmissionPlan(prim0, prim1, prim2, prim3, prim4, prim5);
}

function createNarrowedSegments(prim0, prim1) {
  return SubmitJs.createNarrowedSegments(prim0, prim1);
}

function executeSubmissionPlan(prim0, prim1, prim2, prim3) {
  return SubmitJs.executeSubmissionPlan(prim0, prim1, prim2, prim3);
}

function getGitHubConfig(prim0, prim1) {
  return SubmitJs.getGitHubConfig(prim0, prim1);
}

function formatBookmarkStatus(bookmark, existingPRs) {
  var hasExistingPR = existingPRs.get(bookmark.name);
  return "üìã " + bookmark.name + ": " + (
          bookmark.hasRemote ? "has remote" : "needs push"
        ) + ", " + (
          Core__Option.isSome(hasExistingPR) ? "has PR" : "needs PR"
        );
}

function createExecutionCallbacks() {
  return {
          onPushStarted: (function (bookmark, remote) {
              console.log("Pushing " + bookmark.name + " to " + remote + "...");
            }),
          onPushCompleted: (function (bookmark, remote) {
              console.log("‚úÖ Successfully pushed " + bookmark.name + " to " + remote);
            }),
          onPRStarted: (function (bookmark, title, base) {
              console.log("Creating PR: " + bookmark.name + " -> " + base);
              console.log("   Title: \"" + title + "\"");
            }),
          onPRCompleted: (function (bookmark, pr) {
              console.log("‚úÖ Created PR for " + bookmark.name + ": " + pr.html_url);
              console.log("   Title: " + pr.title);
              console.log("   Base: " + pr.base.ref + " <- Head: " + pr.head.ref);
            }),
          onPRBaseUpdateStarted: (function (bookmark, currentBase, expectedBase) {
              console.log("Updating PR base for " + bookmark.name + " from " + currentBase + " to " + expectedBase + "...");
            }),
          onPRBaseUpdateCompleted: (function (bookmark, pr) {
              console.log("‚úÖ Updated PR base for " + bookmark.name + ": " + pr.html_url);
              console.log("   New Base: " + pr.base.ref + " <- Head: " + pr.head.ref);
            }),
          onError: (function (error, context) {
              var errorMessage = Core__Option.getOr(error.message, "Unknown error");
              console.error("‚ùå Error (" + context + "): " + errorMessage);
            })
        };
}

async function runSubmit(jjFunctions, bookmarkName, changeGraph, dryRun, remote, template) {
  console.log("üîç Analyzing submission requirements for: " + bookmarkName);
  var analysis = SubmitJs.analyzeSubmissionGraph(changeGraph, bookmarkName);
  console.log("‚úÖ Found stack with " + analysis.relevantSegments.length.toString() + " segment(s)");
  var resolvedBookmarks = await Utils.resolveBookmarkSelections(analysis);
  console.log("üîë Getting GitHub authentication...");
  var githubConfig = await SubmitJs.getGitHubConfig(jjFunctions, remote);
  console.log("üìã Creating submission plan...");
  var narrowedSegments = SubmitJs.createNarrowedSegments(resolvedBookmarks, analysis);
  var plan = await createSubmissionPlan(jjFunctions, githubConfig, narrowedSegments, remote, undefined, template);
  console.log("üìç GitHub repository: " + plan.repoInfo.owner + "/" + plan.repoInfo.repo);
  resolvedBookmarks.forEach(function (bookmark) {
        console.log(formatBookmarkStatus(bookmark, plan.existingPRs));
      });
  if (dryRun) {
    console.log("\nüß™ DRY RUN - Simulating all operations:");
    console.log("=".repeat(50));
    if (plan.bookmarksNeedingPush.length > 0) {
      console.log("üì§ Would push: " + plan.bookmarksNeedingPush.length.toString() + " bookmark(s)");
      plan.bookmarksNeedingPush.forEach(function (bookmark) {
            console.log("   ‚Ä¢ " + bookmark.name);
          });
    }
    if (plan.bookmarksNeedingPR.length > 0) {
      console.log("üìù Would create: " + plan.bookmarksNeedingPR.length.toString() + " PR(s)");
      plan.bookmarksNeedingPR.forEach(function (item) {
            console.log("   ‚Ä¢ " + item.bookmark.name + " (base: " + item.baseBranchOptions.join(" or ") + ")");
          });
    }
    if (plan.bookmarksNeedingPRBaseUpdate.length > 0) {
      console.log("üîÑ Would update: " + plan.bookmarksNeedingPRBaseUpdate.length.toString() + " PR base(s)");
      plan.bookmarksNeedingPRBaseUpdate.forEach(function (item) {
            console.log("   ‚Ä¢ " + item.bookmark.name + ": " + item.currentBaseBranch + " ‚Üí " + item.expectedBaseBranchOptions.join(" or "));
          });
    }
    console.log("=".repeat(50));
    console.log("‚úÖ Dry run completed successfully!");
    return ;
  }
  var executionCallbacks = createExecutionCallbacks();
  var result = await executeSubmissionPlan(jjFunctions, plan, githubConfig, Caml_option.some(executionCallbacks));
  if (result.success) {
    console.log("\nüéâ Successfully submitted stack up to " + bookmarkName + "!");
    if (result.pushedBookmarks.length > 0) {
      console.log("   üì§ Pushed: " + result.pushedBookmarks.map(function (b) {
                  return b.name;
                }).join(", "));
    }
    if (result.createdPRs.length > 0) {
      var createdPrBookmarks = result.createdPRs.map(function (pr) {
            return pr.bookmark.name;
          });
      console.log("   üìù Created PRs: " + createdPrBookmarks.join(", "));
    }
    if (result.updatedPRs.length > 0) {
      var updatedPrBookmarks = result.updatedPRs.map(function (pr) {
            return pr.bookmark.name;
          });
      console.log("   üîÑ Updated PRs: " + updatedPrBookmarks.join(", "));
    }
    if (result.errors.length > 0) {
      console.error("\n‚ö†Ô∏è Submission completed with errors:");
      result.errors.forEach(function (param) {
            var errorMessage = Core__Option.getOr(param.error.message, "Unknown error");
            console.error("   ‚Ä¢ " + param.context + ": " + errorMessage);
          });
      return ;
    } else {
      return ;
    }
  }
  Process.exit(1);
}

async function submitCommand(jjFunctions, bookmarkName, options) {
  var dryRun = options !== undefined ? Core__Option.getOr(options.dryRun, false) : false;
  var remote;
  if (options !== undefined) {
    var remote$1 = options.remote;
    remote = remote$1 !== undefined ? remote$1 : Js_exn.raiseError("Remote is required but not provided");
  } else {
    remote = Js_exn.raiseError("Options with remote are required");
  }
  var template;
  if (options !== undefined) {
    var template$1 = options.template;
    template = template$1 !== undefined ? Caml_option.valFromOption(template$1) : undefined;
  } else {
    template = undefined;
  }
  if (dryRun) {
    console.log("üß™ DRY RUN: Simulating submission of bookmark: " + bookmarkName);
  } else {
    console.log("üöÄ Submitting bookmark: " + bookmarkName);
    console.log("Fetching from remote...");
    try {
      await jjFunctions.gitFetch();
    }
    catch (raw_error){
      var error = Caml_js_exceptions.internalToOCamlException(raw_error);
      if (error.RE_EXN_ID === Js_exn.$$Error) {
        console.error("Error fetching from remote: " + Core__Option.getOr(error._1.message, "Unknown error"));
      } else {
        throw error;
      }
    }
  }
  console.log("Building change graph from user bookmarks...");
  var changeGraph = await JjUtilsJs.buildChangeGraph(jjFunctions);
  if (changeGraph.excludedBookmarkCount > 0) {
    console.log("‚ÑπÔ∏è  Found " + changeGraph.excludedBookmarkCount.toString() + " bookmarks on merge commits or their descendants, ignoring.\n   jj-stack works with linear stacking workflows. Consider using 'jj rebase' to linearize your history before creating stacked pull requests.");
    console.log();
  }
  return await runSubmit(jjFunctions, bookmarkName, changeGraph, dryRun, remote, template);
}

export {
  buildChangeGraph ,
  analyzeSubmissionGraph ,
  createSubmissionPlan ,
  createNarrowedSegments ,
  executeSubmissionPlan ,
  getGitHubConfig ,
  formatBookmarkStatus ,
  createExecutionCallbacks ,
  runSubmit ,
  submitCommand ,
}
/* Utils Not a pure module */
