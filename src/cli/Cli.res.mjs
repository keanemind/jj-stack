// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Ink from "ink";
import * as Utils from "./Utils.res.mjs";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Nodeutil from "node:util";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as AuthCommand from "./AuthCommand.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as SubmitCommand from "./SubmitCommand.res.mjs";
import * as AnalyzeCommand from "./AnalyzeCommand.res.mjs";
import * as JjUtilsJs from "../lib/jjUtils.js";
import * as JsxRuntime from "react/jsx-runtime";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as RemoteSelectionComponent from "./RemoteSelectionComponent.res.mjs";

function createJjFunctions(prim) {
  return JjUtilsJs.createJjFunctions(prim);
}

function isGitHubRemote(prim) {
  return JjUtilsJs.isGitHubRemote(prim);
}

var help = "üîß jj-stack - Jujutsu Git workflow automation\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nUSAGE:\n  jj-stack [COMMAND] [OPTIONS]\n\nCOMMANDS:\n  submit <bookmark>     Submit a bookmark and all downstack bookmarks as PRs\n    --dry-run           Show what would be done without making changes\n    --remote <name>     Use the specified Git remote (must be a GitHub remote)\n    --template <name>   Use the specified PR submission template\n\n  auth test             Test GitHub authentication\n  auth help             Show authentication help\n\n  help, --help, -h      Show this help message\n\nDEFAULT BEHAVIOR:\n  Running jj-stack without arguments analyzes and displays the current\n  graph of stacked bookmarks.\n\nEXAMPLES:\n  jj-stack                        # Show change graph\n  jj-stack submit feature-branch  # Submit feature-branch and downstack as PRs\n  jj-stack submit feature-branch --dry-run  # Preview what would be done\n  jj-stack submit feature-branch --remote upstream  # Use a specific remote\n  jj-stack auth test              # Test GitHub authentication\n\nFor more information, visit: https://github.com/keanemind/jj-stack\n";

async function resolveRemoteName(remotes, userSpecified) {
  if (userSpecified !== undefined) {
    var foundRemote = remotes.find(function (r) {
          return r.name === userSpecified;
        });
    if (foundRemote !== undefined) {
      if (!JjUtilsJs.isGitHubRemote(foundRemote.url)) {
        console.error("‚ùå Remote '" + userSpecified + "' is not a GitHub remote. Only GitHub remotes are supported.");
        process.exit(1);
        Js_exn.raiseError("");
      }
      return userSpecified;
    } else {
      console.error("‚ùå Remote '" + userSpecified + "' does not exist.");
      process.exit(1);
      return Js_exn.raiseError("");
    }
  }
  var githubRemotes = remotes.filter(function (r) {
        return JjUtilsJs.isGitHubRemote(r.url);
      });
  var match = githubRemotes.length;
  if (match !== 0) {
    if (match !== 1) {
      console.log("üîÄ Multiple GitHub remotes found, opening interactive selector...");
      console.log();
      return await new Promise((function (resolve, _reject) {
                    var inkInstanceRef = {
                      contents: undefined
                    };
                    var component = JsxRuntime.jsx(RemoteSelectionComponent.make, {
                          remotes: githubRemotes,
                          onComplete: (function (selectedRemoteName) {
                              var instance = inkInstanceRef.contents;
                              if (instance !== undefined) {
                                instance.unmount();
                              }
                              resolve(selectedRemoteName);
                            })
                        });
                    var inkInstance = $$Ink.render(component);
                    inkInstanceRef.contents = inkInstance;
                  }));
    } else {
      return Belt_Array.getExn(githubRemotes, 0).name;
    }
  } else {
    console.error("‚ùå No GitHub remotes found. At least one GitHub remote is required.");
    process.exit(1);
    return Js_exn.raiseError("");
  }
}

async function main() {
  try {
    var jjPathResult = await Utils.getJJPath();
    var jjConfig = {
      binaryPath: jjPathResult.filepath
    };
    var jjFunctions = JjUtilsJs.createJjFunctions(jjConfig);
    var parsed = Nodeutil.parseArgs({
          options: {
            remote: {
              type: "string"
            },
            "dry-run": {
              type: "boolean",
              default: false
            },
            template: {
              type: "string"
            },
            help: {
              type: "boolean",
              short: "h",
              default: false
            }
          },
          allowPositionals: true
        });
    var positionals = parsed.positionals;
    var command = Belt_Array.get(positionals, 0);
    var subArg = Belt_Array.get(positionals, 1);
    var remote = Js_dict.get(parsed.values, "remote");
    var remoteOpt = remote !== undefined ? (
        typeof remote === "string" ? remote : Js_exn.raiseError("--remote was used as a boolean")
      ) : undefined;
    var dryRun = Js_dict.get(parsed.values, "dry-run");
    var isDryRun = dryRun !== undefined ? (
        typeof dryRun === "string" ? Js_exn.raiseError("--dry-run was used as a string") : dryRun
      ) : false;
    var template = Js_dict.get(parsed.values, "template");
    var templateOpt = template !== undefined ? (
        typeof template === "string" ? template : Js_exn.raiseError("--template was used as a boolean")
      ) : undefined;
    var help$1 = Js_dict.get(parsed.values, "help");
    var isHelp = help$1 !== undefined ? (
        typeof help$1 === "string" ? Js_exn.raiseError("--help was used as a string") : help$1
      ) : false;
    var remotes = await jjFunctions.getGitRemoteList();
    var remoteName = await resolveRemoteName(remotes, remoteOpt);
    if (command === undefined) {
      if (isHelp) {
        console.log(help);
        return ;
      } else {
        return await AnalyzeCommand.analyzeCommand(jjFunctions, remoteName, isDryRun, templateOpt);
      }
    }
    switch (command) {
      case "auth" :
          if (isHelp || subArg !== "test") {
            return AuthCommand.authHelpCommand();
          } else {
            return await AuthCommand.authTestCommand();
          }
      case "help" :
          console.log(help);
          return ;
      case "submit" :
          if (isHelp) {
            console.error("Usage: jj-stack submit <bookmark-name> [--dry-run] [--remote <name>] [--template <name>]");
            return ;
          } else if (subArg !== undefined) {
            return await SubmitCommand.submitCommand(jjFunctions, subArg, {
                        dryRun: isDryRun,
                        remote: remoteName,
                        template: Caml_option.some(templateOpt)
                      });
          } else {
            console.error("Usage: jj-stack submit <bookmark-name> [--dry-run] [--remote <name>] [--template <name>]");
            process.exit(1);
            return ;
          }
      default:
        console.error("Unrecognized command: " + command + "\n");
        console.log(help);
        return ;
    }
  }
  catch (raw_error){
    var error = Caml_js_exceptions.internalToOCamlException(raw_error);
    if (error.RE_EXN_ID === Js_exn.$$Error) {
      var message = error._1.message;
      if (message !== undefined) {
        console.error("An error occurred: " + message);
        process.exit(1);
      } else {
        console.error("An unknown error occurred.");
        process.exit(1);
      }
      return ;
    }
    console.error("An unknown error occurred.");
    process.exit(1);
    return ;
  }
}

export {
  createJjFunctions ,
  isGitHubRemote ,
  help ,
  resolveRemoteName ,
  main ,
}
/* ink Not a pure module */
